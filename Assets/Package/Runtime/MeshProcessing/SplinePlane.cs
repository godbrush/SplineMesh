using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace SplineMesh
{
    /// <summary>
    /// SplinePlane is specialized version of <see cref="SplineExtrusion"/>.
    /// Key features:
    /// </summary>
    [ExecuteInEditMode]
    public class SplinePlane : MonoBehaviour
    {
        private Spline spline;
        private bool toUpdate = true;
        private GameObject generated;

        public Material material;
        public Vector4 textureOffsetScale = new Vector4(0, 0, 1, 1);
        public float sampleSpacing = 0.1f;
        public float width = 1;
        public float offset = 0;
        [Range(1, 128)]
        public int slice = 1;
        public bool heightSync = false;
        public LayerMask heightSyncLayerMask = -1;
        public bool heightNormalSync = false;
        public float heightSyncTraceRange = 1.0f;
        public int PerSegmentMaxVertices = 4096;

        [Tooltip("If true, a mesh collider will be generated.")]
        public bool generateCollider = false;

        [Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
        public bool updateInPlayMode;

        private void OnValidate()
        {
            if (spline == null) return;
            toUpdate = true;
        }

        private void OnEnable()
        {
            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => toUpdate = true;
            spline.CurveChanged.AddListener(() => toUpdate = true);
            toUpdate = true;
        }

        private void Update()
        {
            if (false == updateInPlayMode && Application.isPlaying) return;

            if (toUpdate)
            {
                toUpdate = false;
                CreateMeshes();
            }
        }

        private void CreateMeshes()
        {
            if (null == spline) return;

            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);
            generated.isStatic = false == updateInPlayMode;
            generated.layer = gameObject.layer;

            var generatedChildren = generated.transform.Cast<Transform>().ToList();
            foreach (var child in generatedChildren)
            {
                if (null == child) continue;

                var meshCollider = child.GetComponent<MeshCollider>();
                if (meshCollider) meshCollider.enabled = false;
            }

            List<MeshVertex> sourceVertices = new List<MeshVertex>(2 + Mathf.Max(0, slice - 1));
            float x_start = offset - width / 2;
            float x_end = offset + width / 2;

            sourceVertices.Add(new MeshVertex(new Vector3(0, 0, x_start), Vector3.up, new Vector2(+textureOffsetScale.x, 0)));
            for (int step = 1; step < slice; ++step)
            {
                float t = (float) step / (float) slice;
                float x = Mathf.Lerp(x_start, x_end, t);
                sourceVertices.Add(new MeshVertex(new Vector3(0, 0, x), Vector3.up, new Vector2(t / textureOffsetScale.z + textureOffsetScale.x, 0)));
            }
            sourceVertices.Add(new MeshVertex(new Vector3(0, 0, x_end), Vector3.up, new Vector2(1 / textureOffsetScale.z + textureOffsetScale.x, 0)));

            if (Mathf.Approximately(sampleSpacing, 0) || sampleSpacing <= 0)
            {
                Debug.LogError("Not enough sampleSpcaing. (must be greater than zero)");
                return;
            }

            int lineCount = 0;
            List<MeshVertex> bentVertices = new List<MeshVertex>();
            for (float d = 0.0f; d <= spline.Length; d += sampleSpacing)
            {
                var sample = spline.GetSampleAtDistance(d);

                if (heightSync)
                {
                    var sampleLocationWS = spline.transform.TransformPoint(sample.location);
                    RaycastHit hitInfo;
                    if (Physics.Raycast(sampleLocationWS + Vector3.up * heightSyncTraceRange, -Vector3.up, out hitInfo, heightSyncTraceRange * 2, heightSyncLayerMask))
                    {
                        var newSampleLocation = spline.transform.InverseTransformPoint(hitInfo.point);
                        sample = new CurveSample(newSampleLocation, sample.tangent, sample.up, sample.scale, sample.roll, sample.distanceInCurve, sample.timeInCurve, sample.curve);
                    }
                }

                for (int i = 0; i < sourceVertices.Count; ++i)
                {
                    var bentVertex = sample.GetBent(sourceVertices[i]);

                    bentVertex.normal = sample.up;

                    if (heightSync)
                    {
                        var bentWS = spline.transform.TransformPoint(bentVertex.position);
                        RaycastHit hitInfo;
                        if (Physics.Raycast(bentWS + Vector3.up * heightSyncTraceRange, -Vector3.up, out hitInfo, heightSyncTraceRange * 2, heightSyncLayerMask))
                        {
                            bentVertex.position = spline.transform.InverseTransformPoint(hitInfo.point);
                            if (heightNormalSync)
                            {
                                bentVertex.normal = spline.transform.InverseTransformDirection(hitInfo.normal);
                            }
                        }
                    }

                    bentVertex.uv.y = (d / width) / textureOffsetScale.w + textureOffsetScale.y;

                    bentVertices.Add(bentVertex);
                }

                ++lineCount;
            }

            if (1 >= lineCount)
            {
                Debug.LogError("Not enough line length");
                return;
            }

            List<Transform> newGeneratedTransform = new List<Transform>();

            int baseIndex = 0;
            int lineVerticesCount = 2 + Mathf.Max(0, slice - 1);
            List<int> triangles = new List<int>((lineVerticesCount - 1) * (lineCount - 1) * 2);

            for (int i = 0; i < lineCount - 1; ++i)
            {
                int nextBaseIndex = baseIndex + lineVerticesCount;
                for (int v = 0; v < lineVerticesCount - 1; ++v)
                {
                    int[] vertices = new int[] {
                        baseIndex + v, baseIndex + v + 1,
                        nextBaseIndex + v, nextBaseIndex + v + 1
                    };
                    triangles.Add(vertices[0]);
                    triangles.Add(vertices[1]);
                    triangles.Add(vertices[2]);
                    triangles.Add(vertices[2]);
                    triangles.Add(vertices[1]);
                    triangles.Add(vertices[3]);
                }

                bool isOverVertices = nextBaseIndex + lineVerticesCount > PerSegmentMaxVertices;
                bool isEndLine = (i == lineCount - 2);
                bool needGenerateSegment = isOverVertices || isEndLine;

                if (needGenerateSegment)
                {
                    string segmentName = $"{name}-{material.name}-{newGeneratedTransform.Count + 1}";
                    Transform segmentTransform = generated.transform.Find(segmentName);
                    if (null == segmentTransform)
                    {
                        var go = UOUtility.Create(segmentName,
                            generated,
                            typeof(MeshFilter),
                            typeof(MeshRenderer),
                            typeof(MeshCollider));
                        segmentTransform = go.transform;
                    }
                    segmentTransform.gameObject.isStatic = generated.isStatic;
                    segmentTransform.gameObject.layer = generated.layer;

                    newGeneratedTransform.Add(segmentTransform);
                    generatedChildren.Remove(segmentTransform);

                    var meshFilter = segmentTransform.GetComponent<MeshFilter>();
                    var meshRenderer = segmentTransform.GetComponent<MeshRenderer>();
                    var meshCollider = segmentTransform.GetComponent<MeshCollider>();

                    Mesh mesh = meshFilter.sharedMesh;
                    if (null == mesh || mesh.name != segmentName)
                    {
                        mesh = new Mesh();
                    }
                    else if (mesh.vertexCount != bentVertices.Count)
                    {
                        mesh.Clear();
                    }

                    mesh.name = segmentName;
                    mesh.hideFlags = HideFlags.HideInHierarchy;
                    mesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt16;

                    var segmentBentVertices = bentVertices.GetRange(0, nextBaseIndex + lineVerticesCount);

                    mesh.SetVertices(segmentBentVertices.Select(b => b.position).ToList());
                    mesh.SetNormals(segmentBentVertices.Select(b => b.normal).ToList());
                    mesh.SetUVs(0, segmentBentVertices.Select(b => b.uv).ToList());
                    mesh.SetTriangles(triangles, 0, false);

                    mesh.RecalculateBounds();
                    mesh.RecalculateTangents();

                    meshFilter.sharedMesh = mesh;
                    meshRenderer.material = material;
                    meshCollider.sharedMesh = mesh;

                    meshCollider.enabled = generateCollider;

                    triangles.Clear();
                    bentVertices.RemoveRange(0, nextBaseIndex);

                    nextBaseIndex = 0;
                }

                baseIndex = nextBaseIndex;
            }

            foreach (var deprecatedTransform in generatedChildren)
            {
                if (deprecatedTransform != null)
                {
                    UOUtility.Destroy(deprecatedTransform.gameObject);
                }
            }
        }
    }
}
