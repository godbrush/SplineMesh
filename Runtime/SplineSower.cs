using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// SplineSower is specialized version of <see cref="ExampleSower"/>'
    /// Additional features:
    /// - Height sync
    /// - Height(up) offset
    /// - Layer modified.
    /// </summary>
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineSower : MonoBehaviour {
        private GameObject generated;
        private Spline spline = null;
        private bool toUpdate = true;

        public GameObject prefab = null;
        public float scale = 1, scaleRange = 0;
        public float spacing = 1, spacingRange = 0;
        public float widthOffset = 0, widthOffsetRange = 0;
        public float heightOffset = 0, heightOffsetRange = 0;
        public bool isRandomYaw = false;
        public int randomSeed = 0;

        public bool updateInPlayMode;
        public bool heightSync = false;
        public LayerMask heightSyncLayerMask = -1;
        public bool heightNormalSync = false;
        public float heightSyncTraceRange = 1.0f;

        private void OnEnable() {
            string generatedName = "generated by "+GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

            generated.isStatic = false == updateInPlayMode;
            generated.layer = gameObject.layer;

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (s, e) => {
                toUpdate = true;
                foreach (CubicBezierCurve curve in spline.GetCurves()) {
                    curve.Changed.AddListener(() => toUpdate = true);
                }
            };
            foreach (CubicBezierCurve curve in spline.GetCurves()) {
                curve.Changed.AddListener(() => toUpdate = true);
            }
        }

        private void OnValidate() {
            toUpdate = true;
        }

        private void Update() {
            if (false == updateInPlayMode && Application.isPlaying) return;

            if (toUpdate) {
                Sow();
                toUpdate = false;
            }
        }

        public void Sow() {
            UOUtility.DestroyChildren(generated);

            UnityEngine.Random.InitState(randomSeed);
            if (spacing + spacingRange <= 0 ||
                prefab == null)
                return;

            float distance = 0;
            while (distance <= spline.Length) {
                CurveSample sample = spline.GetSampleAtDistance(distance);
                if (heightSync)
                {
                    var sampleLocationWS = spline.transform.TransformPoint(sample.location);
                    RaycastHit hitInfo;
                    if (Physics.Raycast(sampleLocationWS + Vector3.up * heightSyncTraceRange, -Vector3.up, out hitInfo, heightSyncTraceRange * 2, heightSyncLayerMask))
                    {
                        var newSampleLocation = spline.transform.InverseTransformPoint(hitInfo.point);
                        var newSampleUp = heightNormalSync ? spline.transform.InverseTransformDirection(hitInfo.normal) : sample.up;
                        sample = new CurveSample(newSampleLocation, sample.tangent, newSampleUp, sample.scale, sample.roll, sample.distanceInCurve, sample.timeInCurve, sample.curve);
                    }
                }

                GameObject go;
                go = Instantiate(prefab, generated.transform);
                go.transform.localRotation = Quaternion.identity;
                go.transform.localPosition = Vector3.zero;
                go.transform.localScale = Vector3.one;

                go.isStatic = false == updateInPlayMode;
                go.layer = gameObject.layer;
                foreach(var child in go.transform.Cast<Transform>())
                {
                    child.gameObject.layer = go.layer;
                }

                // move along spline, according to spacing + random
                go.transform.localPosition = sample.location;
                // apply scale + random
                float rangedScale = scale + UnityEngine.Random.Range(0, scaleRange);
                go.transform.localScale = new Vector3(rangedScale, rangedScale, rangedScale);
                // rotate with random yaw
                if (isRandomYaw) {
                    go.transform.Rotate(0, 0, UnityEngine.Random.Range(-180, 180));
                } else {
                    go.transform.rotation = sample.Rotation;
                }
                // move orthogonaly to the spline, according to offset + random
                var binormal = (Quaternion.LookRotation(sample.tangent, sample.up) * Vector3.right).normalized;
                var localWidthOffset = widthOffset + UnityEngine.Random.Range(0, widthOffsetRange * Math.Sign(widthOffset));
                var localHeightOffset = heightOffset + UnityEngine.Random.Range(0, heightOffsetRange * Math.Sign(heightOffset));

                localWidthOffset *=  sample.scale.x;
                binormal *= localWidthOffset;
                go.transform.position += binormal + sample.up * localHeightOffset;

                distance += spacing + UnityEngine.Random.Range(0, spacingRange);
            }
        }
    }
}
